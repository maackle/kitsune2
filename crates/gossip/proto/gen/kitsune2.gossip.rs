// This file is @generated by prost-build.
/// A Kitsune2 gossip protocol message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipMessage {
    /// The type of this message.
    #[prost(enumeration = "k2_gossip_message::GossipMessageType", tag = "1")]
    pub msg_type: i32,
    /// The payload or content of this message.
    #[prost(bytes = "bytes", tag = "2")]
    pub data: ::prost::bytes::Bytes,
}
/// Nested message and enum types in `K2GossipMessage`.
pub mod k2_gossip_message {
    /// These enum variants correspond to `K2Gossip*Message` types,
    /// e.g. `INITIATE` -> `K2GossipInitiateMessage`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GossipMessageType {
        Unspecified = 0,
        /// A gossip initiation protocol message.
        Initiate = 1,
        /// A gossip acceptance protocol message.
        Accept = 2,
        /// A gossip no diff protocol message.
        NoDiff = 3,
        /// A gossip disc sectors diff protocol message.
        DiscSectorsDiff = 4,
        /// A gossip disc sector details diff protocol message.
        DiscSectorDetailsDiff = 5,
        /// A gossip disc sector details diff response protocol message.
        DiscSectorDetailsDiffResponse = 6,
        /// A gossip ring sector details diff protocol message.
        RingSectorDetailsDiff = 7,
        /// A gossip ring sector details diff response protocol message.
        RingSectorDetailsDiffResponse = 8,
        /// A gossip hashes protocol message.
        Hashes = 9,
        /// A gossip agents protocol message.
        Agents = 10,
        /// A gossip busy protocol message.
        Busy = 11,
        /// A gossip terminate protocol message.
        Terminate = 12,
    }
    impl GossipMessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Initiate => "INITIATE",
                Self::Accept => "ACCEPT",
                Self::NoDiff => "NO_DIFF",
                Self::DiscSectorsDiff => "DISC_SECTORS_DIFF",
                Self::DiscSectorDetailsDiff => "DISC_SECTOR_DETAILS_DIFF",
                Self::DiscSectorDetailsDiffResponse => {
                    "DISC_SECTOR_DETAILS_DIFF_RESPONSE"
                }
                Self::RingSectorDetailsDiff => "RING_SECTOR_DETAILS_DIFF",
                Self::RingSectorDetailsDiffResponse => {
                    "RING_SECTOR_DETAILS_DIFF_RESPONSE"
                }
                Self::Hashes => "HASHES",
                Self::Agents => "AGENTS",
                Self::Busy => "BUSY",
                Self::Terminate => "TERMINATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "INITIATE" => Some(Self::Initiate),
                "ACCEPT" => Some(Self::Accept),
                "NO_DIFF" => Some(Self::NoDiff),
                "DISC_SECTORS_DIFF" => Some(Self::DiscSectorsDiff),
                "DISC_SECTOR_DETAILS_DIFF" => Some(Self::DiscSectorDetailsDiff),
                "DISC_SECTOR_DETAILS_DIFF_RESPONSE" => {
                    Some(Self::DiscSectorDetailsDiffResponse)
                }
                "RING_SECTOR_DETAILS_DIFF" => Some(Self::RingSectorDetailsDiff),
                "RING_SECTOR_DETAILS_DIFF_RESPONSE" => {
                    Some(Self::RingSectorDetailsDiffResponse)
                }
                "HASHES" => Some(Self::Hashes),
                "AGENTS" => Some(Self::Agents),
                "BUSY" => Some(Self::Busy),
                "TERMINATE" => Some(Self::Terminate),
                _ => None,
            }
        }
    }
}
/// A message representation of a Kitsune2 DHT arc set.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ArcSetMessage {
    /// The encoded representation of covered DHT sectors.
    #[prost(uint32, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u32>,
}
/// Common fields to be sent in response to an accept message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AcceptResponseMessage {
    /// Agent ids of agents that were mentioned in the acceptor's participating_agents list
    /// that we do not have in our peer store.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub missing_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// The agent infos for the agents that were sent back in the missing_agents list in the acceptor's response.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub provided_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Ops that we have stored since the timestamp provided by the acceptor in `new_since`.
    #[prost(bytes = "bytes", repeated, tag = "3")]
    pub new_ops: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Provide a new bookmark for the initiator. Any new ops will have been returned in `new_ops`
    /// and the acceptor should use this new timestamp in their `new_since` next time they gossip with us.
    #[prost(int64, tag = "4")]
    pub updated_new_since: i64,
}
/// A Kitsune2 gossip initiation protocol message.
///
/// Acceptable responses:
/// - `K2GossipAcceptMessage`
/// - `K2GossipBusyMessage`
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipInitiateMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    /// The agent ids of the agents from the initiator who are in the peer store for the space where gossip is running.
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub participating_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// The DHT sectors covered by the union of the agents in the participating_agents list.
    #[prost(message, optional, tag = "11")]
    pub arc_set: ::core::option::Option<ArcSetMessage>,
    /// A tie breaker so that conflicting initiates between a pair of peers can be resolved without a further message.
    ///
    /// This must be a random number, selected per gossip round.
    #[prost(uint32, tag = "12")]
    pub tie_breaker: u32,
    /// Request ops that are new since the given timestamp.
    #[prost(int64, tag = "20")]
    pub new_since: i64,
    /// Gossip exchanges just op ids. This value is a hint to the other party about how many bytes of op data
    /// those op ids should point to. The other party can't check this until they have fetched and checked the
    /// op data, so you cannot rely on this being respected during gossip.
    #[prost(uint32, tag = "21")]
    pub max_op_data_bytes: u32,
}
/// A Kitsune2 gossip acceptance protocol message.
///
/// Acceptable responses:
/// - `K2GossipNoDiffMessage`
/// - `K2GossipDiscSectorsDiffMessage`
/// - `K2GossipRingSectorDetailsDiffMessage`
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipAcceptMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    /// The agent ids of the agents from the acceptor who are in the peer store for the space where gossip is running.
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub participating_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// The DHT sectors covered by the union of the agents in the participating_agents list.
    #[prost(message, optional, tag = "11")]
    pub arc_set: ::core::option::Option<ArcSetMessage>,
    /// Agent ids of agents that were mentioned in the initiator's participating_agents list
    /// that we do not have in our peer store.
    #[prost(bytes = "bytes", repeated, tag = "12")]
    pub missing_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Request ops that are new since the given timestamp.
    #[prost(int64, tag = "20")]
    pub new_since: i64,
    /// Gossip exchanges just op ids. This value is a hint to the other party about how many bytes of op data
    /// those op ids should point to. The other party can't check this until they have fetched and checked the
    /// op data, so you cannot rely on this being respected during gossip.
    #[prost(uint32, tag = "21")]
    pub max_op_data_bytes: u32,
    /// Ops that we have stored since the timestamp provided by the initiator in `new_since`.
    #[prost(bytes = "bytes", repeated, tag = "22")]
    pub new_ops: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Provide a new bookmark for the initiator. Any new ops will have been returned in `new_ops`
    /// and the initiator should use this new timestamp in their `new_since` next time they gossip with us.
    #[prost(int64, tag = "23")]
    pub updated_new_since: i64,
    /// The DHT snapshot of the acceptor.
    #[prost(message, optional, tag = "30")]
    pub snapshot: ::core::option::Option<
        k2_gossip_accept_message::SnapshotMinimalMessage,
    >,
}
/// Nested message and enum types in `K2GossipAcceptMessage`.
pub mod k2_gossip_accept_message {
    /// Message representation of kitsune2_dht::DhtSnapshot::Minimal
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SnapshotMinimalMessage {
        #[prost(int64, tag = "1")]
        pub disc_boundary: i64,
        #[prost(bytes = "bytes", tag = "2")]
        pub disc_top_hash: ::prost::bytes::Bytes,
        #[prost(bytes = "bytes", repeated, tag = "3")]
        pub ring_top_hashes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    }
}
/// A Kitsune2 gossip no diff protocol message.
///
/// Should be sent as a response to an `K2GossipAcceptMessage` to communicate that there was no diff
/// or that a diff could not be computed.
///
/// Acceptable responses:
/// - `K2GossipAgentsMessage`
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipNoDiffMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub accept_response: ::core::option::Option<AcceptResponseMessage>,
    /// Set when the initiator could not compare the acceptor's DHT diff with their own.
    #[prost(bool, tag = "10")]
    pub cannot_compare: bool,
}
/// A Kitsune2 gossip disc sectors diff protocol message.
///
/// Acceptable responses:
/// - `K2GossipDiscSectorDetailsDiffMessage`
/// - `K2GossipAgentsMessage`
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipDiscSectorsDiffMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "2")]
    pub accept_response: ::core::option::Option<AcceptResponseMessage>,
    #[prost(message, optional, tag = "10")]
    pub snapshot: ::core::option::Option<
        k2_gossip_disc_sectors_diff_message::SnapshotDiscSectorsMessage,
    >,
}
/// Nested message and enum types in `K2GossipDiscSectorsDiffMessage`.
pub mod k2_gossip_disc_sectors_diff_message {
    /// Message representation of kitsune2_dht::DhtSnapshot::DiscSectors
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SnapshotDiscSectorsMessage {
        #[prost(int64, tag = "1")]
        pub disc_boundary: i64,
        #[prost(uint32, repeated, tag = "2")]
        pub disc_sectors: ::prost::alloc::vec::Vec<u32>,
        #[prost(bytes = "bytes", repeated, tag = "3")]
        pub disc_sector_hashes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiscSliceHashes {
    #[prost(uint64, repeated, tag = "1")]
    pub slice_indices: ::prost::alloc::vec::Vec<u64>,
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub hashes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
/// Message representation of kitsune2_dht::DhtSnapshot::DiscSectorDetails
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotDiscSectorDetailsMessage {
    #[prost(int64, tag = "1")]
    pub disc_boundary: i64,
    #[prost(uint32, repeated, tag = "2")]
    pub sector_indices: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub disc_slice_hashes: ::prost::alloc::vec::Vec<DiscSliceHashes>,
}
/// A Kitsune2 gossip disc sector details diff protocol message.
///
/// Acceptable responses:
/// - `K2GossipDiscSectorDetailsDiffResponseMessage`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct K2GossipDiscSectorDetailsDiffMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    /// The agent infos for the agents that were sent back in the missing_agents list of the previous message.
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub provided_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "20")]
    pub snapshot: ::core::option::Option<SnapshotDiscSectorDetailsMessage>,
}
/// A Kitsune2 gossip disc sector details diff protocol message.
///
/// Acceptable responses:
/// - `K2GossipHashesMessage`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct K2GossipDiscSectorDetailsDiffResponseMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub missing_ids: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "20")]
    pub snapshot: ::core::option::Option<SnapshotDiscSectorDetailsMessage>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RingSectorHashes {
    #[prost(uint32, repeated, tag = "1")]
    pub sector_indices: ::prost::alloc::vec::Vec<u32>,
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub hashes: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
/// Message representation of kitsune2_dht::DhtSnapshot::RingSectorDetails
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotRingSectorDetailsMessage {
    #[prost(int64, tag = "1")]
    pub disc_boundary: i64,
    #[prost(uint32, repeated, tag = "2")]
    pub ring_indices: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub ring_sector_hashes: ::prost::alloc::vec::Vec<RingSectorHashes>,
}
/// A Kitsune2 gossip ring sector details diff protocol message.
///
/// Acceptable responses:
/// - `K2GossipRingSectorDetailsDiffResponseMessage`
/// - `K2GossipAgentsMessage`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct K2GossipRingSectorDetailsDiffMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "10")]
    pub accept_response: ::core::option::Option<AcceptResponseMessage>,
    #[prost(message, optional, tag = "20")]
    pub snapshot: ::core::option::Option<SnapshotRingSectorDetailsMessage>,
}
/// A Kitsune2 gossip ring sector details diff response protocol message.
///
/// Acceptable responses:
/// - `K2GossipHashesMessage`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct K2GossipRingSectorDetailsDiffResponseMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub missing_ids: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(message, optional, tag = "20")]
    pub snapshot: ::core::option::Option<SnapshotRingSectorDetailsMessage>,
}
/// A Kitsune2 gossip hashes protocol message.
///
/// This message is a final message when used in a gossip round.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipHashesMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub missing_ids: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
/// A Kitsune2 gossip agents protocol message.
///
/// This message is a final message when used in a gossip round.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipAgentsMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    /// The agent infos for the agents that were sent back in the missing_agents list of the previous message.
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub provided_agents: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
/// A Kitsune2 gossip busy protocol message.
///
/// If the receiver of an initiate is busy and will not accept the round, they should respond with this message instead.
/// This allows the initiator to retry the round later, without waiting for a timeout.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipBusyMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
}
/// A Kitsune2 gossip terminate protocol message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct K2GossipTerminateMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub session_id: ::prost::bytes::Bytes,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
